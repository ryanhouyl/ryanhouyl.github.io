<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>零拷贝技术解析 | 0x80x17</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">零拷贝技术解析</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">零拷贝技术解析</h1><div class="post-meta">2022-10-04</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zero-copy-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Zero-copy 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">应用场景及实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-transfer-The-traditional-approach"><span class="toc-text">Data transfer: The traditional approach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-transfer-The-zero-copy-approach"><span class="toc-text">Data transfer: The zero-copy approach</span></a></li></ol></div></div><div class="post-content"><p>本文为翻译文章，原文链接为: <a target="_blank" rel="noopener" href="https://developer.ibm.com/technologies/java/articles/j-zerocopy/">Efficient data transfer through zero copy</a></p>
<h3 id="Zero-copy-是什么"><a href="#Zero-copy-是什么" class="headerlink" title="Zero-copy 是什么"></a>Zero-copy 是什么</h3><blockquote>
<p>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.       – from Wikipedia</p>
</blockquote>
<span id="more"></span>

<h3 id="应用场景及实现原理"><a href="#应用场景及实现原理" class="headerlink" title="应用场景及实现原理"></a>应用场景及实现原理</h3><p>许多 web 应用都会提供从磁盘读取大量的静态数据，然后再把这些数据写到 response socket 中。这种服务看起来几乎不会用到 cpu 计算，但事实并非如此：内核从磁盘读取数据后，会把它通过 kernel-user 边界 push 到应用，然后再通过kernel-user 边界 push 回 socket buffer 供 socket 写出。实际上，这里应用层成了磁盘和 socket 之间一个低效的中间介质</p>
<p>每次数据通过 kernel-user 边界时，必须被复制，这就会消耗cpu cycles 和内存带宽。幸运的是，我们可以通过 <code>zero copy</code> 技术来消除这些拷贝。<strong>使用 zero copy技术，应用可以直接把磁盘数据移动到 socket，不需要经过应用</strong>。zero copy 技术提升了应用性能并且减少了 kernel 和 user 模式的切换</p>
<p>Java 类库通过 <code>java.nio.channels.FileChannel</code> 类的<code>transferTo()</code> 方法支持在 Linux 和 Unix 操作系统上的zero copy 技术。你可以使用 transferTo() 方法把字节流从调用这个方法的 channel 直接转移到另一个可写的字节channel，数据不需要经过应用。本文首先会证明使用传统的复制语义会带来 overhead，然后展示使用 zero copy 技术的transferTo() 方法如何实现更好的性能</p>
<h3 id="Data-transfer-The-traditional-approach"><a href="#Data-transfer-The-traditional-approach" class="headerlink" title="Data transfer: The traditional approach"></a>Data transfer: The traditional approach</h3><p>考虑这样一个场景：从文件中读取数据然后通过网络把数据传输到另一个程序中(这个场景描述了很多服务应用的行为，包括提供静态内容的 web 应用，FTP 服务器，邮件服务等)，这个操作的核心代码如下 Listing1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing1 Copying bytes from a file to a socket</span></span><br><span class="line">File.read(fileDesc, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br></pre></td></tr></table></figure>

<p>尽管 Listing1 看起来很简单，但在内部这个 copy 操作需要在 user 模式和 kernel 模式间转换4次，数据也需要拷贝4次。下面 Figure1 展示了数据是如何从文件移动到 socket 的：</p>
<p>Figure1 Traditional data copying approach</p>
<p><img src="https://0x80x17.tech/img/zeroCopy/figure1.png"></p>
<p>Figure2 展示了上下文的切换：</p>
<p>Figure2 Traditional context switches</p>
<p><img src="https://0x80x17.tech/img/zeroCopy/figure2.png"></p>
<p>涉及到的步骤如下：</p>
<ol>
<li>read() 调用会导致图二中从用户模式到内核模式的切换。Figure1 中的第一次复制是通过 DMA（Direct Memory Access），从磁盘中读取文件内容然后保存到内核地址空间的buffer(CPU 不参与复制)</li>
<li>请求的数据从内核 read buffer 被复制到 user buffer，然后 read() 调用返回。从 call 调用返回导致上下文从内核态切换回用户态。现在数据保存在用户地址空间的buffer</li>
<li>socket 的 send() 方法调用使用户态再一次切换到内核态，第三次拷贝再一次把数据复制到内核地址空间的 buffer，但是这一次数据被放在了不同的 buffer，这个 buffer 与目标socket 相关联</li>
<li>send() 系统调用返回，导致第四次上下文切换，第四次拷贝发生在 DMA 引擎把数据从内核 buffer 传递到 protocol 引擎</li>
</ol>
<p>使用作为间接层的内核 buffer(而不是直接把数据转移到用户buffer)看起来是很低效的。但是内核缓存被引入进程却提高了性能，使用内核缓存在读取数据量不大于缓存容量的数据时，可以把应用数据缓存到内核 buffer 作为 “readahead cache”，这能很好的提高性能。同时该中间缓存允许写数据实现异步</p>
<p>不幸的是，<strong>当请求的数据比内核 buffer 的容量大很多时，这种方式就变成了性能瓶颈。数据在磁盘，内核 buffer，用户buffer，与应用之间被复制了多次。Zero copy 通过消除这些冗余的数据拷贝来提升性能</strong>（注：本来是为了提升性能引入的内核缓存，却在特殊的场景下成为了性能的阻碍。软件开发中通过引入中间层可以解决所有问题，但同时也会引入新的问题）</p>
<h3 id="Data-transfer-The-zero-copy-approach"><a href="#Data-transfer-The-zero-copy-approach" class="headerlink" title="Data transfer: The zero-copy approach"></a>Data transfer: The zero-copy approach</h3><p>如果你再看一下上面传统的复制方式，你会注意到第二次和第三次的数据拷贝并不是必须的。应用除了缓存数据然后把数据移动到 socket buffer 外，什么也没有做。事实上，数据可以从 read buffer 直接移动到 socket buffer。transferTo() 方法就是这样做的。Listing2 展示了该方法签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing2 The transferTo() method()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferTo</span><span class="params">(<span class="type">long</span> position, <span class="type">long</span> count, WritableByteChannel target)</span>;</span><br></pre></td></tr></table></figure>

<p>transferTo() 方法把数据从一个文件 channel 转移到另一个可写的字节 channel，这依赖于底层的操作系统支持 zero copy；在 Unix  和各种 Linux系统中，通过 <code>sendfile()</code>系统调用来实现，在 Listing3 中展示了数据从一个文件 descriptor 转移到另一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing3 the sendfile() system call</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>在 Listing1 中的 <code>file.read()</code> 和 <code>socket.send()</code> 调用可以被 Listing4 中的一个 transferTo() 调用替换:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing4 Using transferTo() to copy data from a disk file to a socket</span></span><br><span class="line">transferTo(position, count, writableChannel);</span><br></pre></td></tr></table></figure>

<p>Figure3 展示了当 transferTo() 方法被调用时数据的移动：</p>
<p>Figure3 Data copy with transferTo()</p>
<p><img src="https://0x80x17.tech/img/zeroCopy/figure3.png"></p>
<p>Figure4 展示了 transferTo 方法调用时上下文的切换</p>
<p>Figure4 Context switching with transferTo()</p>
<p><img src="https://0x80x17.tech/img/zeroCopy/figure4.png"></p>
<p>在 Listing4 中使用 transferTo() 方法时的步骤为：</p>
<ol>
<li>transferTo 方法使文件内容通过 DMA 被拷贝到 read buffer，然后数据再被内核拷贝到与输出 socket 相关的内核buffer</li>
<li>第三次拷贝发生在 DMA 把数据从内核 socket buffer 传递到 protocol 引擎</li>
</ol>
<p>上面的操作发生了如下改进：我们把上下文切换从四次减少到了两次，把数据拷贝从四次减少到了三次（只有一次需要cpu参与）。但是这还没有到达我们 zero copy 的目标，我们可以进一步减少数据复制如果底层的网络接口支持 <code>gather operations</code>。在 Linux2.4 及以后的内核版本中，socket buffer descriptor 被修改用来支持该操作。这不仅减少了上下文的切换，而且消除了需要 cpu 参与的那次内存复制。客户端的使用保持不变，但是内在的操作发生了变化：</p>
<ol>
<li>transferTo() 方法使文件内容通过 DMA 被拷贝到内核buffer</li>
<li>没有数据被拷贝到 socket buffer。相应的，只有带有关于数据位置和数据长度信息的 descriptors 被 append 到socket buffer。DMA 直接把数据从内核缓存传递到 protocol 引擎，因此消除了仅有的那一次 cpu 拷贝</li>
</ol>
<p>Figure5 展示了使用 gather operation 的 transferTo 方法的数据拷贝过程：</p>
<p>Figure5 Data copies when transferTo() and gather operations are used</p>
<p><img src="https://0x80x17.tech/img/zeroCopy/figure5.png"></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>零拷贝技术解析</p><p><span>文章作者：</span>Ryan</p><p><span>原始链接：</span><a href="/2022/10/04/零拷贝技术解析/">https://0x80x17.tech/2022/10/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://0x80x17.tech/2022/10/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/"></i></span></p><p><span>版权声明：</span>转载或引用请注明本文链接🔗</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul></div><div class="post-nav"><a class="pre" href="/2022/10/11/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/">Redis Cluster扩展性和可用性设计</a><a class="next" href="/2022/09/25/Sharding-IDs-at-Instagram/">Sharding &amp; IDs at Instagram</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">语法</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/04/30/%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7/">熔断&降级</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/19/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">关于流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/%E8%81%8A%E8%81%8A%E5%B9%82%E7%AD%89/">聊聊幂等</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/15/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-2/">Java 内存模型解读(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/12/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-1/">Java 内存模型解读(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/29/%E5%86%8D%E8%B0%88-Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">再谈 Java线程池</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>