<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java 线程池实现原理 | 0x80x17</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 线程池实现原理</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 线程池实现原理</h1><div class="post-meta">2022-11-02</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">为什么要使用线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">实现线程池要考虑的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">ThreadPoolExecutor的代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor%E6%8E%A5%E5%8F%A3"><span class="toc-text">Executor接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-text">线程池的状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-text">如何控制线程池的线程数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">execute方法的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">创建线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#workQueue%E7%9A%84%E6%8E%92%E9%98%9F%E7%AD%96%E7%95%A5"><span class="toc-text">workQueue的排队策略</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><p>在开发中，我们使用多线程来处理多个任务，一般是先编写实现任务的代码(任务类一般实现<code>Runnable</code>接口)，然后为每个任务启动一个线程(<code>Thread</code>类)，接下来由系统负责完成线程间的调度。假设任务很多，而且执行时间不长，为每个任务都创建一个对应的线程，<strong>会使线程频繁的创建和销毁，所以我们引入线程池，控制线程创建的数目，尽量的使线程可以复用。</strong></p>
<h2 id="实现线程池要考虑的问题"><a href="#实现线程池要考虑的问题" class="headerlink" title="实现线程池要考虑的问题"></a>实现线程池要考虑的问题</h2><ul>
<li>线程池自身的状态如何管理？比如 running, shutdown 等</li>
<li>如何控制线程池的线程数目？</li>
<li>线程池如何执行待处理的任务？</li>
<li>如何控制待执行的任务和线程之间的关系？</li>
</ul>
<span id="more"></span>

<h2 id="ThreadPoolExecutor的代码分析"><a href="#ThreadPoolExecutor的代码分析" class="headerlink" title="ThreadPoolExecutor的代码分析"></a>ThreadPoolExecutor的代码分析</h2><p>关于一个线程池的实现，在上面给出了几个需要重点关注的地方，下面结合源码进行解析</p>
<h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><blockquote>
<p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.</p>
</blockquote>
<p>该接口把任务的提交和任务的执行进行解耦，至于如何执行提交的任务，可以有很多不同的实现，在 Oracle 提供的 API 文档中，有详细的描述。后面我们会详细了解 <code>ThreadPoolExecutor</code> 是如何实现该接口的 <code>execute(Runnable command)</code>方法的</p>
<h3 id="线程池的状态管理"><a href="#线程池的状态管理" class="headerlink" title="线程池的状态管理"></a>线程池的状态管理</h3><p>在 <code>ThreadPoolExecutor</code>类中定义了一个线程池的状态，并且提供了对应的锁，来保证状态修改的同步，同时还有与线程池状态相关的操作，比如<code>shutdown(), shutdownNow()</code>等；在执行线程池中的任务时，也需要对线程池的状态进行判断，一些重要的字段如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<h3 id="如何控制线程池的线程数"><a href="#如何控制线程池的线程数" class="headerlink" title="如何控制线程池的线程数"></a>如何控制线程池的线程数</h3><p>首先要关注几个重要的字段：</p>
<ul>
<li><code>private volatile int corePoolSize; // 核心池的大小</code>,在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中</li>
<li><code>private volatile int maxinumPoolSize; // 线程池最大线程数</code></li>
<li><code>private final BlockingQueue&lt;Runnable&gt; workQueue; // 任务缓存队列，用存放等待执行的任务</code></li>
<li><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</code> &#x2F;&#x2F; Set containing all worker threads in pool. Accessed only when holding mainLock.（其中Worker 包装了具体要执行的任务和执行该任务的线程）</li>
</ul>
<p><code>ThreadPoolExecutor</code> 类大体实现的思路：当线程池中的线程数小于核心池<strong>corePoolSize</strong>时，直接创建线程(通过Worker)执行该任务，方法为 <code>addIfUnderCorePoolSize(command)</code>; 当线程池中的线程数大于核心池corePoolSize时，把任务加入到缓存队列<code>workQueue.offer(command)</code>，队列中的任务会通过<code>getTask()</code> 方法获取</p>
<h3 id="execute方法的实现"><a href="#execute方法的实现" class="headerlink" title="execute方法的实现"></a>execute方法的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<p>首先，判断提交的任务command是否为null，若是null，则抛出空指针异常</p>
<blockquote>
<p>接着是这句，这句要好好理解一下：<code>if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))</code>由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了<br><br>如果线程池中<strong>当前线程数小于核心池大小</strong>，则接着执行后半部分，也就是执行<code>addIfUnderCorePoolSize(command)</code>如果执行完<code>addIfUnderCorePoolSize</code>这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了<br><br>如果执行完<code>addIfUnderCorePoolSize</code>这个方法返回false，然后接着判断：<code>if (runState == RUNNING &amp;&amp; workQueue.offer(command))</code>如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：<code>addIfUnderMaximumPoolSize(command)</code>如果执行<code>addIfUnderMaximumPoolSize</code>方法失败，则执行<code>reject()</code>方法进行任务拒绝处理<br><br>回到前面 <code>if (runState == RUNNING &amp;&amp; workQueue.offer(command))</code>这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：<br><code>if (runState != RUNNING || poolSize == 0)</code><br>这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：<code>ensureQueuedTaskHandled(command)</code>进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。</p>
</blockquote>
<p>接下里重点关注 <code>addIfUnderCorePoolSize(Runnable firstTask)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);   </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中通过 addThread(firstTask) 把待执行的任务交给 Thread 对象，然后通过 <code>t.start()</code> 启动线程，等待任务执行</p>
<p>那么顺着代码执行，下面关注一下<code>addThread(Runnable command)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Thread <span class="title function_">addThread</span><span class="params">(Runnable firstTask)</span> &#123;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> threadFactory.newThread(w);  <span class="comment">//创建一个线程，执行任务   </span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        w.thread = t;            <span class="comment">//将创建的线程的引用赋值为w的成员变量       </span></span><br><span class="line">        workers.add(w);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nt</span> <span class="operator">=</span> ++poolSize;     <span class="comment">//当前线程数加1       </span></span><br><span class="line">        <span class="keyword">if</span> (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = nt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过该方法，我们知道了执行任务的线程和线程池是通过 <code>Worker</code> 和 <code>HashSet&lt;Worker&gt;</code> 来封装执行，所以接下关注 <code>Worker</code> 的<code>run</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> firstTask;</span><br><span class="line">            firstTask = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                runTask(task);</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerDone(<span class="built_in">this</span>);          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过<code>getTask()</code>去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取。这里有一个非常巧妙的设计，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里<strong>直接让执行完任务的线程去任务缓存队列里面取任务来执行</strong></p>
<p>Worker 的 run 方法调用了 <code>runTask(task)</code> 方法来最终执行任务，所以我们再看下该方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">runLock</span> <span class="operator">=</span> <span class="built_in">this</span>.runLock;</span><br><span class="line">       runLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (runState &lt; STOP &amp;&amp;</span><br><span class="line">               Thread.interrupted() &amp;&amp;</span><br><span class="line">               runState &gt;= STOP)</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">           beforeExecute(thread, task);         </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               task.run();</span><br><span class="line">               ran = <span class="literal">true</span>;</span><br><span class="line">               afterExecute(task, <span class="literal">null</span>);</span><br><span class="line">               ++completedTasks;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ran)</span><br><span class="line">                   afterExecute(task, ex);</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           runLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>看到代码里的 <code>task.run()</code> 我们总算可以松一口气了，这就是我们的任务实际要执行的代码</p>
<p>总结一下一个任务的执行顺序：通过把任务提交给 ThreadPoolExecutor 的 execute(Runnable) 方法，为每个任务创建一个对应的 Worker 对象，该对象封装了执行该任务的线程，通过在该对象 <code>run()</code> 方法获取要执行的任务(包括通过 <code>getTask()</code> 方法从队列中去取)，并最终调用 <code>runTask(task)</code>来执行任务的代码(task.run())</p>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>提倡直接使用ThreadPoolExecutor的构造函数，而不是使用<code>Executors</code>类中提供的几个静态方法来创建线程池（Executors 方法用起来方便，但是有坑，后面会专门介绍）</p>
<h3 id="workQueue的排队策略"><a href="#workQueue的排队策略" class="headerlink" title="workQueue的排队策略"></a>workQueue的排队策略</h3><p>workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：</p>
<ul>
<li>ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小</li>
<li>LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE</li>
<li>synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</li>
</ul>
<p><strong>具体的内容在 java.util.concurrent.ThreadPoolExecutor API 文档中说的很清楚，比如使用 ArrayBlockingQueue 时，如何在 queue size 和 maximum pool size 之间作 trade off，建议去仔细看一下</strong></p>
<p>以上就是关于一个线程池实现原理的主要讲述，当然还有很多细节没有说，比如如何通过锁处理线程并发，建议去看源码和注释。</p>
<hr>
<p><strong>推荐阅读：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3932921.html">Java并发编程：线程池的使用</a></li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>Java 线程池实现原理</p><p><span>文章作者：</span>Ryan</p><p><span>原始链接：</span><a href="/2022/11/02/Java-线程池实现原理/">https://0x80x17.tech/2022/11/02/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://0x80x17.tech/2022/11/02/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"></i></span></p><p><span>版权声明：</span>转载或引用请注明本文链接🔗</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" rel="tag">线程&amp;并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul></div><div class="post-nav"><a class="pre" href="/2022/11/13/Visitor-Pattern-Tutorial/">Visitor Pattern Tutorial</a><a class="next" href="/2022/10/11/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/">Redis Cluster扩展性和可用性设计</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">语法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" style="font-size: 15px;">数据存储</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 15px;">安全</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/07/09/%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">位图与布隆过滤器</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/01/%E5%85%B3%E4%BA%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">关于负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/17/%E5%85%B3%E4%BA%8E-Skip-list/">关于 Skip list</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/30/%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7/">熔断&降级</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/19/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">关于流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/%E8%81%8A%E8%81%8A%E5%B9%82%E7%AD%89/">聊聊幂等</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>