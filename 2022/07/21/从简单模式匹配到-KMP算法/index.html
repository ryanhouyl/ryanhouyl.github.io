<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>从简单模式匹配到 KMP算法 | 0x80x17</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">从简单模式匹配到 KMP算法</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">从简单模式匹配到 KMP算法</h1><div class="post-meta">2022-07-21</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div></div></div><div class="post-content"><p>在日常编程中，字符串的使用是相当频繁的，从一个文本串中找到另一个我们需要的子串是常见的场景，所以有必要了解一下模式匹配的知识</p>
<p>本文主要从思路上来比较简单模式匹配与 KMP 算法的不同之处，体会<strong>解决问题的思路</strong>对于算法设计的重要性。当然程序的编写也有用到一些技巧，不过技巧这种东西随着不断练习只是时间问题，而思路这东西就未必了，尤其是原创性的思路</p>
<span id="more"></span>

<p>先从最简单的模式匹配算法开始说，面对这样一个问题：给定一个文本串和模式串，要求我们从文本串中查找是否存在模式串，如果存在则返回文本串中开始匹配模式串的位置，否则返回 -1。看到这个问题我们不难得到一种简单直观的思路：</p>
<p>保持模式串不动，用文本串第一个字符与模式串第一个字符比较，如果相等，继续比较文本串和模式串的下一个字符；如果不相等，文本串左移一个字符，下一次从第二个字符开始再次与模式串从头比较 ；如果匹配成功则返回开始匹配的位置，否则返回-1即可</p>
<p>这种思路其实是一种遍历的方式，找出文本串中从任一位置开始的可能情况，这里说成<strong>模式串不动，文本串每次左移一个单位</strong>会更直观一些。这属于一种<strong>暴力解法</strong>，算法的时间复杂度为<code>O(m*n)</code>(m,n为文本串和模式串的长度)。反正不论什么问题，穷举法总是可以得到正确答案，计算机嘛，这点比我们强多了，算得快，慢慢试呗，不过这种方法总觉得有点”low”啊，下面来看下大牛解决问题的思路</p>
<p>模式匹配的 KMP 算法：这里 KMP 三个字母分别为三位大神名字的首字母（K 我们比较熟悉了，<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>）KMP 这个算法的思路很巧妙，对比上面介绍的简单算法，这里先把 KMP 算法概括为一句话：<strong>文本串固定不动，模式串右移进行匹配</strong></p>
<p>先回想一下我们第一个算法的弊端，时间复杂度为<code>O(m*n)</code>，分析一下不难得出原因，每次匹配失败，不管匹配了多少个字符，我们的文本串<strong>仅仅左移一个字符的位置</strong>，文本串本来就很长，这样匹配就太慢了，做了好多无用功。所以 KMP 算法的主要想法就是<strong>在比较失败时，尽可能快的让模式串全部比较完，而不是简单的从头开始。</strong>怎么做呢？这里通过右移模式串的方式来实现，那么问题来了，怎么右移模式串呢？这里需要我们了解关于前缀串和后缀串的知识，还有一个用来记录最长匹配长度的 next 数组(求next数组就是整个算法的关键问题了)，下面通过例子和代码具体说明。</p>
<p>我们先来人工求一个 next 数组感受一下这是怎样一个过程，在进行匹配时，模式串匹配失效的位置前面的子串我们称为S串。假设模式串为 <strong>ABABABB</strong></p>
<p>对于一个给定字符串，求最大匹配的前缀串和后缀串我们应该比较熟悉，而 next 数组记录的就是这个最大匹配的长度：</p>
<ul>
<li>当模式串第一个字符与文本串第一个字符不匹配时，从文本串的下一个位置与模式串继续比较，next[0] 设置为-1来表示这种特殊情况</li>
<li>当模式串第二个字符与文本串对应位置不匹配时，此时S串为A，不存在匹配的前缀串和后缀串，next[1] 设置为0</li>
<li>当模式串第三个字符与文本串对应位置不匹配时，此时S串为AB，不存在匹配的前缀串和后缀串，next[2] 设置为0</li>
<li>当模式串第四个字符与文本串对应位置不匹配时，此时S串为ABA，存在最大匹配的前缀串和后缀串A，next[3]设置为1</li>
<li>当模式串第五个字符与文本串对应位置不匹配时，此时S串为ABAB，存在最大匹配的前缀串和后缀串AB，next[4]设置为2</li>
<li>依次类推，可得<code>next = &#123;-1, 0, 0, 1, 2, 3, 4&#125;</code></li>
</ul>
<p>通过这个过程我们应该发现了，求 next 数组的过程存在一个递归调用：如果我们已经求出了<code>next[n]</code>的数值，如何求<code>next[n+1]</code>？假设<code>next[n]=k</code>，即0到 k-1 位置的子串与 n-k 到 n-1 位置的子串是匹配。这里分为两种情况：</p>
<ul>
<li>模式串下标 k 处的字符与 n 处的字符匹配，即0到k位置的子串与n-k到n位置的子串匹配，显然有 <code>next[n+1] = next[n] + 1 = k + 1</code></li>
<li>模式串下标k处的字符与n处的字符不匹配，这时我们需要<strong>对0到k-1位置的字符串递归的使用模式匹配</strong>，也就是为了消除n处的不匹配，我们需要“缩短”0到k-1位置的子串为0到next[k]（这个也比较好证明，根据next数组的定义作个图即可明白）<br>求 next 数组的代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getNextArray</span><span class="params">(String needle, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>[] source = needle.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; needle.length(); i++) &#123;</span><br><span class="line">        fillNext(source, next, i, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fillNext</span><span class="params">(<span class="type">char</span>[] source, <span class="type">int</span>[] next, <span class="type">int</span> i, <span class="type">int</span> pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (next[pre] == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//  递归出口</span></span><br><span class="line">        next[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source[i - <span class="number">1</span>] == source[next[pre]]) &#123;</span><br><span class="line">            next[i] = next[pre] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            fillNext(source, next, i, next[pre]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在给出 KMP 算法的代码前，我们还需要清楚关于模式串移动的问题。其实这个思路也不难理解，因为我们在前面是根据最大匹配的前缀串和后缀串来求得next数组，比如假设 <code>next[j] = k</code>，这代表j位置之前的模式串子串中，有最大长度为k的相同前缀和后缀(也就是0到k-1位置的子串与j-k到j-1位置的子串完全一样)。<strong>当模式串在j处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串右移<code>j - next[j]</code>，</strong>下面给出KMP算法的具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">KMP</span><span class="params">(String haystack, String needle, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] source = haystack.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] pattern = needle.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pattern.length &amp;&amp; j &lt; source.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == source[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line">    <span class="keyword">return</span> j == pattern.length ? i - pattern.length : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样通过固定文本串，右移模式串的方式，我们可以在某一位置匹配失败时对文本串进行快速的检索，而不是按部就班的一个字符一个字符的移动文本串，整个算法的时间复杂度变为<code>O(m+n)</code>，为线性时间</p>
<p>KMP 算法的设计思路的确很巧妙，虽然整个思路不难理解，但是很多细节还是比较琐碎，建议不太清楚的时候在纸上演算一下运行过程以加深理解，尤其是对于next数组的求解部分和移动距离的理解。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>从简单模式匹配到 KMP算法</p><p><span>文章作者：</span>Ryan</p><p><span>原始链接：</span><a href="/2022/07/21/从简单模式匹配到-KMP算法/">https://0x80x17.tech/2022/07/21/%E4%BB%8E%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%88%B0-KMP%E7%AE%97%E6%B3%95/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://0x80x17.tech/2022/07/21/%E4%BB%8E%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%88%B0-KMP%E7%AE%97%E6%B3%95/"></i></span></p><p><span>版权声明：</span>转载或引用请注明本文链接🔗</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" rel="tag">数据结构&amp;算法</a></li></ul></div><div class="post-nav"><a class="pre" href="/2022/08/03/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM 类加载器</a><a class="next" href="/2022/06/21/null-awareness/">null awareness</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">语法</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 15px;">安全</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/06/01/%E5%85%B3%E4%BA%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">关于负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/17/%E5%85%B3%E4%BA%8E-Skip-list/">关于 Skip list</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/30/%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7/">熔断&降级</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/19/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">关于流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/%E8%81%8A%E8%81%8A%E5%B9%82%E7%AD%89/">聊聊幂等</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/15/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-2/">Java 内存模型解读(2)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>