<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>模版方法模式VS策略模式 | 0x80x17</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">模版方法模式VS策略模式</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">模版方法模式VS策略模式</h1><div class="post-meta">2022-02-16</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-text">模版方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">涉及到的设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">比较两种模式</span></a></li></ol></div></div><div class="post-content"><p>模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述</p>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote>
<p>在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤</p>
</blockquote>
<span id="more"></span>

<p>模版方法模式符合<strong>好莱坞原则(Don’t call us, we’ll call u.)<strong>，好莱坞原则给我们提供了一种防止”依赖腐败”的方法(代码中的依赖关系尽量要保持单向且不循环)，在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件。换句话说，</strong>高层组件对待低层组件的方式是”别调用我们,我们会调用你”</strong></p>
<p>模版方法模式也符合**开闭原则(OCP)**，算法骨架保持稳定，对修改封闭；通过子类对扩展保持开放</p>
<p>下面是<code>Head First 设计模式</code>中的一段代码，代码中有关于如何在抽象基类中定义算法骨架并定义子类扩展点的注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CaffeineBeverageWithHook</span> &#123;</span><br><span class="line">    <span class="comment">// 模版方法,定义算法骨架和子类扩展点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 提供钩子方法,控制部分算法的执行,由子类决定是否覆盖该钩子方法</span></span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 交由不同子类具体实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boiling water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pouring into cup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个钩子方法,通常是空的缺省实现,由子类决定是否覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">customerWantsCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模版方法模式在实际使用中是很广泛的，比如 Spring 框架中 <code>BeanFactory</code> 就使用了该模式，并把 getBean() 方法交给不同的子类具体实现；JDK 中 <code>ThreadPoolExecutor</code> 类的 runWorker() 方法就定义了 <code>beforeExecute</code> 和 <code>afterExecute</code> 钩子方法。在实际工作中，我个人也比较喜欢用这个模式，当存在两个行为类似但又不完全相同的类时，可以考虑提取公共流程和可复用的代码到父类，保留不同的地方作为 abstract 方法，交由不同的子类去实现</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</p>
</blockquote>
<p>策略模式重在定义不同的算法(行为)接口，然后为每个接口提供不同的实现类，在客户端代码中，通过组合的方式使用抽象的接口，甚至可以提供动态改变算法策略的 API，利用多态和依赖注射的方式灵活的组合和替换具体的算法</p>
<h3 id="涉及到的设计原则"><a href="#涉及到的设计原则" class="headerlink" title="涉及到的设计原则"></a>涉及到的设计原则</h3><p><strong>封装变化</strong>: 找出应用中可能会变化的部分，把它们抽象出来，这样系统中该部分改变不会影响其他部分</p>
<p><strong>针对接口编程而不是针对实现编程</strong>: 这里针对接口编程的真正意思是<strong>针对超类型(supertype)编程。</strong>针对接口编程的精髓在于多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上（为程序提供了动态性）</p>
<p><strong>多用组合，少用继承(实现继承)</strong>: “有一个”可能比”是一个”更好。当将两个类组合起来使用时,就是组合(composition)，使用组合建立系统具有很大的弹性，不仅可以将算法族封装成类，更可以在”运行时动态的改变行为”</p>
<p>具体的示例代码建议去看<code>Head First 设计模式</code>一书，清晰易懂</p>
<p>策略模式在实际应用中也比较广泛，比如在 Netty 中，<code>EventExecutorChooser</code> 作为事件执行器选择策略接口，存在<code>PowerOfTwoEventExecutorChooser</code> 和 <code>GenericEventExecutorChooser</code> 两个具体实现类，<code>DefaultEventExecutorChooserFactory</code> 的 newChooser 方法作为策略选择者，会根据执行器数量是否能被2整数选择具体的策略实现。我自己在实际工作中也用过多次，比如在重构系统中一个关于车辆出库的方法时，该方法会判断不同的出库类型，根据类型不同，执行不同的出库逻辑，整个代码通过 if-else 组合，足足有近千行，而且不同的出库逻辑会根据需求存在变动，每次变动都要修改这里的 if-else 逻辑，维护和测试很不方便。通过抽象出一个出库策略接口，然后为不同的出库方式提供不同的实现，并提供一个根据出库方式选择具体策略实现类的策略者，该方法被简化为只有几十行代码，当出库需求变动时，只需要修改需求变动的出库方式对应的出库策略实现类即可，其他的代码均保持不变，符合开闭原则</p>
<h2 id="比较两种模式"><a href="#比较两种模式" class="headerlink" title="比较两种模式"></a>比较两种模式</h2><ul>
<li>策略模式侧重于定义一个<strong>算法家族</strong>，并且让算法可以互换，强调灵活性</li>
<li>而模版方法模式侧重于定义出<strong>算法骨架</strong>，子类可以通过钩子方法指定部分行为。方便代码复用和框架定义，强调的是算法骨架的稳定性</li>
<li>策略模式采用组合的方式实现，更加有弹性; 模版方法模式采用继承的方式实现</li>
</ul>
<p>最后再举个例子，在 <code>Head Fist 设计模式</code> 中提到，Java <code>Arrays</code>类的排序方法也提供了一种模版方法模式的变式: 在 <code>mergeSort</code> 模版方法中, 依赖于 <code>comparable</code> 接口的 <code>compareTo</code> 方法来完成算法；我认为这里理解为策略模式也是合理的，<code>comparable</code> 可以理解为一个算法家族的接口，可以有不同的实现方法，当 <code>mergeSort</code> 方法接收到此类型的具体参数，实质上就是采用了某个具体的策略。从不同的角度来看，我认为这两种观点都有道理，所以说这两种模式确实存在相似性。还是一贯的观点，编程是一门实践性很强的学科，很多时候死抠概念是没意思的，况且有的概念本身就没有定论，而有自己的思考和想法非常重要。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>模版方法模式VS策略模式</p><p><span>文章作者：</span>Ryan</p><p><span>原始链接：</span><a href="/2022/02/16/模版方法模式VS策略模式/">https://0x80x17.tech/2022/02/16/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://0x80x17.tech/2022/02/16/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"></i></span></p><p><span>版权声明：</span>转载或引用请注明本文链接🔗</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul></div><div class="post-nav"><a class="pre" href="/2022/02/27/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/">创建一个对象的思考</a><a class="next" href="/2022/02/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/">单例模式的各种姿势</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">语法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" style="font-size: 15px;">数据存储</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 15px;">安全</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/07/09/%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">位图与布隆过滤器</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/01/%E5%85%B3%E4%BA%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">关于负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/17/%E5%85%B3%E4%BA%8E-Skip-list/">关于 Skip list</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/30/%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7/">熔断&降级</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/19/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">关于流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/%E8%81%8A%E8%81%8A%E5%B9%82%E7%AD%89/">聊聊幂等</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>