<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>0x80x17 | hello, world:)</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">0x80x17</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2022/04/05/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8-Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">回调及在 Java中的使用</a></h1><div class="post-meta">2022-04-05</div><div class="post-content"><h2 id="回调是什么"><a href="#回调是什么" class="headerlink" title="回调是什么"></a>回调是什么</h2><p>维基百科的定义如下:</p>
<blockquote>
<p>In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.</p>
</blockquote>
<p>可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)</p></div><p class="readmore"><a href="/2022/04/05/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8-Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/03/19/Debunking-the-Myths-of-RPC-REST/">Debunking the Myths of RPC&amp;REST</a></h1><div class="post-meta">2022-03-19</div><div class="post-content"><p>本文为翻译文章，原文链接为:<a target="_blank" rel="noopener" href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/">Debunking the Myths of RPC &amp; REST</a></p>
<p>网上有很多关于 RPC 和 REST 的文章，博客与讨论，但是大部分都在回答某一个特定的应用下，应该选择使用 RPC 还是 REST，而这本身并不是一个正确的二分法。这些回答普遍没有解释我想要知道的问题，而是让我感觉到大部分的开发者并不懂为什么要使用 REST，仅仅是因为觉得这个架构听起来很酷。讽刺的是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a>在介绍 REST 的论文中就提到了这种**”design by fad”**</p>
<blockquote>
<p>“Consider how often we see software projects begin with adoption of the latest fad in architectural design, and only later discover whether or not the system requirements call for such an architecture.”</p>
</blockquote></div><p class="readmore"><a href="/2022/03/19/Debunking-the-Myths-of-RPC-REST/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/03/03/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%80%9D%E8%B7%AF/">反转单链表的三种经典思路</a></h1><div class="post-meta">2022-03-03</div><div class="post-content"><p>基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路。</p>
<h2 id="头插法构建单链表"><a href="#头插法构建单链表" class="headerlink" title="头插法构建单链表"></a>头插法构建单链表</h2><p>头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 <code>O(n)</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkNode <span class="title function_">reverse</span><span class="params">(LinkNode head)</span> &#123;</span><br><span class="line">    <span class="type">LinkNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkNode</span>(head.val);</span><br><span class="line">        cur.next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2022/03/03/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%80%9D%E8%B7%AF/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/02/27/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/">创建一个对象的思考</a></h1><div class="post-meta">2022-02-27</div><div class="post-content"><h2 id="事情可能没有看起来那么简单"><a href="#事情可能没有看起来那么简单" class="headerlink" title="事情可能没有看起来那么简单"></a>事情可能没有看起来那么简单</h2><p>Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？</p>
<ul>
<li>创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？</li>
<li>数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？</li>
<li>时间: 是立即构建，还是延迟构建呢？</li>
<li>形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？</li>
</ul></div><p class="readmore"><a href="/2022/02/27/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/02/16/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">模版方法模式VS策略模式</a></h1><div class="post-meta">2022-02-16</div><div class="post-content"><p>模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述</p>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote>
<p>在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤</p>
</blockquote></div><p class="readmore"><a href="/2022/02/16/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/02/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/">单例模式的各种姿势</a></h1><div class="post-meta">2022-02-02</div><div class="post-content"><p>在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下</p>
<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：</p></div><p class="readmore"><a href="/2022/02/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/01/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式</a></h1><div class="post-meta">2022-01-15</div><div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>适配器模式将一个类的接口，转换成客户期望的另一个接口，让原本接口不兼容的类可以合作无间</p>
</blockquote>
<p>举个简单例子，插头与插座，通过电源适配器，可以把插头与本来不相匹配的插座进行适配，这样做的好处显然易见，<strong>既不用重新更换插头，也不用更换插座，只需要使用一个适配器就可以使插头与插座适配工作</strong>，而这也就是适配器模式的设计初衷，通过引入一个中间层，屏蔽底层变动对于上层的影响</p></div><p class="readmore"><a href="/2022/01/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/12/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A-fail-fast%E7%AD%96%E7%95%A5/">迭代器模式及 fail-fast策略</a></h1><div class="post-meta">2021-12-22</div><div class="post-content"><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>迭代器模式提供了一种顺序访问一个聚合对象中的各个元素，而又不暴露其内部数据结构的方式。把遍历的任务放在迭代器上而不是聚合上</p>
<h2 id="为什么需要迭代器"><a href="#为什么需要迭代器" class="headerlink" title="为什么需要迭代器"></a>为什么需要迭代器</h2><p>思考这样一个问题，客户端中有一个类，需要访问不同的聚合对象，遍历各个聚合对象的所有元素，来进行相应的操作，应该怎么做？</p>
<p>最简单直接的方式当然是由各个聚合对象来提供遍历的接口，在客户端的类中调用这个接口来实现遍历，这样当然可以，但我们可以思考一下这样做的弊端：</p></div><p class="readmore"><a href="/2021/12/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A-fail-fast%E7%AD%96%E7%95%A5/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/12/08/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP/">Java 动态代理实现AOP</a></h1><div class="post-meta">2021-12-08</div><div class="post-content"><p>AOP(Aspect Oriented Programming)也就是我们说的面向切面编程，可以看作面向对象编程的一种补充。AOP 应用很广，比如 Spring 框架中的 @Transactional 声明式事务就是借助 AOP 实现的。</p>
<h3 id="为什么要使用AOP？"><a href="#为什么要使用AOP？" class="headerlink" title="为什么要使用AOP？"></a>为什么要使用AOP？</h3><p>试想这样一个场景，假如需要在所有已经实现的业务方法中添加打印日志的功能，该怎么实现？把打印日志的代码复制粘贴到每一个业务方法中？这样当然可以，但是弊端很明显：</p></div><p class="readmore"><a href="/2021/12/08/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/11/23/Java-Checked-Unchecked-Exception/">Java Checked&amp;Unchecked Exception</a></h1><div class="post-meta">2021-11-23</div><div class="post-content"><h2 id="Is-checked-exception-necessary"><a href="#Is-checked-exception-necessary" class="headerlink" title="Is checked exception necessary?"></a>Is checked exception necessary?</h2><p>很多言论认为 Java 受检异常(checked exception，也就是那些你需要明确的捕获或者 rethrow 的异常)的存在是没有必要的，例如在 C# 语言中就取消了受检异常，而且大部分的语言都没有受检异常这一概念，无论何时直接声明异常为 RuntimeException 或其子类(即 unchecked exception)会更加方便，事实是如此吗？</p></div><p class="readmore"><a href="/2021/11/23/Java-Checked-Unchecked-Exception/">阅读全文</a></p></div><nav class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/04/05/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8-Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">回调及在 Java中的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/19/Debunking-the-Myths-of-RPC-REST/">Debunking the Myths of RPC&REST</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/03/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%80%9D%E8%B7%AF/">反转单链表的三种经典思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/27/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/">创建一个对象的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/16/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">模版方法模式VS策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/">单例模式的各种姿势</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/01/15/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A-fail-fast%E7%AD%96%E7%95%A5/">迭代器模式及 fail-fast策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/12/08/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0AOP/">Java 动态代理实现AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/23/Java-Checked-Unchecked-Exception/">Java Checked&Unchecked Exception</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>