<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>0x80x17 | hello, world:)</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">0x80x17</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></h1><div class="post-meta">2023-02-19</div><div class="post-content"><p>前面写的关于ThreadLocal的文章<a href="https://0x80x17.tech/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a>，主要从ThreadLocal的一些基本知识和代码实现思路来整理，本文将试着从更加深入的角度来看ThreadLocal以及在使用TreadLocal 中遇到的一些坑。</p>
<h3 id="设计初衷"><a href="#设计初衷" class="headerlink" title="设计初衷"></a>设计初衷</h3><p>一句话：<strong>提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</strong></p>
<p>稍微展开来说一点，ThreadLocal的作用是提供线程内的局部变量 (类比方法的局部变量)，这种变量在自身线程的生命周期内起作用（其他线程访问不到），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度（同时隔离了多个线程）。</p>
<p>从上面的设计初衷，我们不难得出ThreadLocal的使用场景：</p></div><p class="readmore"><a href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></h1><div class="post-meta">2023-02-12</div><div class="post-content"><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>这个类的名字已经很清楚的告诉我们该类的作用了，即<code>线程局部变量</code>，可以类比一般的局部变量，<code>ThreadLocal</code>说明了该局部变量的上下文环境为<code>Thread</code>，即每个线程都有一个互不影响的变量，可以通过<code>get()</code>或者<code>set(T value)</code>等方法分别操作自己的变量副本，而对其他的线程操作保持封闭</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>那么为什么需要使用ThreadLocal呢？可以考虑这样两个场景：</p>
<ul>
<li>在同一个线程中的多个函数需要操作相同的数据，怎么处理？一种比较直接的方式就是通过在多个函数之间进行参数的传递，但是这种方式需要给每个参与的方法都增加一个参数，这并不优雅</li>
<li>针对上面的问题，我们可以提供一个全局变量供所有的函数访问，但是在多线程环境下，需要进行同步处理</li>
</ul></div><p class="readmore"><a href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></h1><div class="post-meta">2023-01-15</div><div class="post-content"><p>接着上一篇关于AQS的文章 <a href="https://0x80x17.tech/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a> 继续分析，接下来是AQS框架的第二个重要组成部分。</p>
<h3 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h3><p>在 JSR166 之前，除了基于内置的 monitor 的方法外(wait&#x2F;notify)，Java 没有可用的API用于线程阻塞和唤醒操作来实现同步器。唯一可用的备选方案是 <code>Thread.suspend</code> 和 <code>Thread.resume</code>，但是这两个方法在遇到竞态问题时会出现无法解决的问题，比如：当一个当前未被阻塞的线程在一个线程执行 <code>suspend</code> 方法之前调用 <code>resume</code>  方法，那么这个 <code>resume</code> 方法将没有任何效果(后面提到的 LockSupport 通过给每个线程引入一个permit解决了这个问题)</p></div><p class="readmore"><a href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a></h1><div class="post-meta">2023-01-09</div><div class="post-content"><p>本文部分内容来自<code>Doug Lea</code>的论文<code>The java.util.concurrent Synchronizer Framework</code>和 jdk 中相关文档与源码，非常推荐大家去认真读一下这篇论文和相关代码，对AQS这个框架有一个全面的了解</p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>AQS即<code>AbstractQueuedSynchronizer</code>，在jdk中大部分的同步器比如<code>locks, barriers, semaphore</code>等都是基于该框架实现的。这个框架提供了一些公共的方法用来<strong>原子化的管理同步状态，阻塞和唤醒线程，以及排队</strong>(这三个部分也是这个框架最核心的三部分组成，后面会逐一分析)。</p></div><p class="readmore"><a href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/12/15/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-2/">Java 内存模型解读(2)</a></h1><div class="post-meta">2022-12-15</div><div class="post-content"><p>接着上一篇文章 <a href="https://0x80x17.tech/2022/12/12/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-1/">Java 内存模型解读(1)</a> 继续整理Java内存模型相关的重要知识</p>
<h3 id="incorrectly-synchronized-program"><a href="#incorrectly-synchronized-program" class="headerlink" title="incorrectly synchronized program"></a>incorrectly synchronized program</h3><p>没有正确进行同步的代码对于不同的人来说可能代表不同的事儿，当我们在Java内存模型的上下文中讨论没有正确进行同步的代码时，我们指任何满足下面条件的代码：</p>
<ul>
<li>一个线程正在写一个变量</li>
<li>另外一个线程同时正在读同一个变量</li>
<li>这两个线程之间的读写操作没有通过同步来保证顺序</li>
</ul>
<p>当上面的规则被违背时，我们说那个变量出现了<strong>data race</strong>。一个存在竞态数据的程序是没有正确同步的程序。</p></div><p class="readmore"><a href="/2022/12/15/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-2/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/12/12/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-1/">Java 内存模型解读(1)</a></h1><div class="post-meta">2022-12-12</div><div class="post-content"><p>理解 Java内存模型，是更好的学习Java多线程并发和使用相关工具类&#x2F;关键字的基础，本文主要参考了：<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ</a> 和 <a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/">The Java Memory Model</a>。推荐去看这两份权威文档。</p>
<h3 id="why-should-I-care？"><a href="#why-should-I-care？" class="headerlink" title="why should I care？"></a>why should I care？</h3><p>主要原因在于并发程序很难debug。一般的测试很难发现问题，只有当你的系统负载比较大时问题才会出现，而且很难复现和捕捉。所以最好多花精力让我们的程序能正确的处理同步问题而不是寄希望于debug。 <strong>while this is not easy, it’s a lot easier than trying to debug a badly synchronized application.</strong></p></div><p class="readmore"><a href="/2022/12/12/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-1/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/11/29/%E5%86%8D%E8%B0%88-Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">再谈 Java线程池</a></h1><div class="post-meta">2022-11-29</div><div class="post-content"><p>前面写过一篇关于线程池的文章，<a href="https://0x80x17.tech/2022/11/02/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Java线程池实现原理</a>，侧重于从代码的角度(主要是execute方法的实现)来解释线程池的实现，本文将结合一些例子来谈谈实际使用中遇到的问题，侧重于从使用层面看待线程池。</p>
<h2 id="线程池使用中涉及的重要问题"><a href="#线程池使用中涉及的重要问题" class="headerlink" title="线程池使用中涉及的重要问题"></a>线程池使用中涉及的重要问题</h2><p>还是再强调一下，Executor 和 ThreadPoolExecutor 这两个接口&#x2F;类，一定去认真读一下jdk文档，写的很好</p>
<p>先从<code>ThreadPoolExecutor</code>实现的顶层接口<code>Executor</code>来说，该接口设计的目的是为了实现任务提交和任务执行解耦，线程池类ThreadPoolExecutor实现了该接口，因此能将任务的提交与执行进行解耦，不仅如此，通过池化技术，可以控制线程的创建销毁，可以复用线程资源，减少开销，同时提供对于线程等资源的管理</p></div><p class="readmore"><a href="/2022/11/29/%E5%86%8D%E8%B0%88-Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/11/13/Visitor-Pattern-Tutorial/">Visitor Pattern Tutorial</a></h1><div class="post-meta">2022-11-13</div><div class="post-content"><p>本文为翻译文章，介绍一个比较强大的设计模式 – <strong>Visitor pattern</strong>，原文链接为: <a target="_blank" rel="noopener" href="https://dzone.com/articles/design-patterns-visitor">Visitor Pattern Tutorial with Java Examples</a></p>
<h2 id="Visitors-in-the-Real-World"><a href="#Visitors-in-the-Real-World" class="headerlink" title="Visitors in the Real World"></a>Visitors in the Real World</h2><p>通过类比真实世界可以帮助更好的理解设计模式。已打出租车为例，乘客叫好车后，车来了，乘客上车，这时出租车就会为乘客提供运送服务(个人觉得这个例子可以帮助理解但不是特别好，下面的例子更好些)</p>
<p>在超市购物是另一个比较好的例子，购物车里放的是你购买的各种商品。当你去结账的时候，收银员就扮演了一个 visitor 的角色，他会一个一个的处理你购物车里的商品，有些标有价格，有些需要称重，处理完后会得到你购物的总花费。</p>
<p>其实这是一个比较难通过现实世界来解释的模式，所以接下来我们通过模式的定义和示例代码来更清楚的学习这个模式。</p></div><p class="readmore"><a href="/2022/11/13/Visitor-Pattern-Tutorial/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/11/02/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Java 线程池实现原理</a></h1><div class="post-meta">2022-11-02</div><div class="post-content"><h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><p>在开发中，我们使用多线程来处理多个任务，一般是先编写实现任务的代码(任务类一般实现<code>Runnable</code>接口)，然后为每个任务启动一个线程(<code>Thread</code>类)，接下来由系统负责完成线程间的调度。假设任务很多，而且执行时间不长，为每个任务都创建一个对应的线程，<strong>会使线程频繁的创建和销毁，所以我们引入线程池，控制线程创建的数目，尽量的使线程可以复用。</strong></p>
<h2 id="实现线程池要考虑的问题"><a href="#实现线程池要考虑的问题" class="headerlink" title="实现线程池要考虑的问题"></a>实现线程池要考虑的问题</h2><ul>
<li>线程池自身的状态如何管理？比如 running, shutdown 等</li>
<li>如何控制线程池的线程数目？</li>
<li>线程池如何执行待处理的任务？</li>
<li>如何控制待执行的任务和线程之间的关系？</li>
</ul></div><p class="readmore"><a href="/2022/11/02/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/10/11/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/">Redis Cluster扩展性和可用性设计</a></h1><div class="post-meta">2022-10-11</div><div class="post-content"><h2 id="Redis-Cluster-如何解决扩展性问题"><a href="#Redis-Cluster-如何解决扩展性问题" class="headerlink" title="Redis Cluster 如何解决扩展性问题"></a>Redis Cluster 如何解决扩展性问题</h2><p>思考如下场景，当单台 redis 服务节点存储容量达到上限，不考虑加内存等垂直扩展方式，如何通过增加 redis 服务节点实现水平扩展？增加服务节点本身不是难点所在，问题在于增加了服务节点后，客户端如何确定需要访问哪个服务节点？</p>
<p>最简单的方式是客户端计算出 key 的哈希值后，对服务节点数量做取模运算，结果即为服务节点下标值(服务节点从零开始进行编号)。当然弊端也很明显，一旦增加或者删除节点，会导致大量缓存键失效重建，一般不会采用这种实现。</p></div><p class="readmore"><a href="/2022/10/11/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/">阅读全文</a></p></div><nav class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/15/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-2/">Java 内存模型解读(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/12/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-1/">Java 内存模型解读(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/29/%E5%86%8D%E8%B0%88-Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">再谈 Java线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/13/Visitor-Pattern-Tutorial/">Visitor Pattern Tutorial</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/02/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Java 线程池实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/11/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/">Redis Cluster扩展性和可用性设计</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>