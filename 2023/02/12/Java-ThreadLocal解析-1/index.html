<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java ThreadLocal解析(1) | 0x80x17</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java ThreadLocal解析(1)</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java ThreadLocal解析(1)</h1><div class="post-meta">2023-02-12</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text">举个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">ThreadLocal的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84API"><span class="toc-text">重要的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-get-%E6%96%B9%E6%B3%95%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8BThreadLocal%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">通过 get() 方法的源码分析下ThreadLocal的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-text">ThreadLocal的内存泄漏问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="toc-text">参考文章：</span></a></li></ol></div></div><div class="post-content"><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>这个类的名字已经很清楚的告诉我们该类的作用了，即<code>线程局部变量</code>，可以类比一般的局部变量，<code>ThreadLocal</code>说明了该局部变量的上下文环境为<code>Thread</code>，即每个线程都有一个互不影响的变量，可以通过<code>get()</code>或者<code>set(T value)</code>等方法分别操作自己的变量副本，而对其他的线程操作保持封闭</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>那么为什么需要使用ThreadLocal呢？可以考虑这样两个场景：</p>
<ul>
<li>在同一个线程中的多个函数需要操作相同的数据，怎么处理？一种比较直接的方式就是通过在多个函数之间进行参数的传递，但是这种方式需要给每个参与的方法都增加一个参数，这并不优雅</li>
<li>针对上面的问题，我们可以提供一个全局变量供所有的函数访问，但是在多线程环境下，需要进行同步处理</li>
</ul>
<span id="more"></span>

<p>综合上面两种情况，我们引入了ThreadLocal变量，提供了线程上下文环境下的局部变量</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>在分析<code>ThreadLocal</code>的实现原理前，我们先看一个示例代码：</p>
<p>有三个线程，每个线程都有一个值value，初始值为0，线程运行时用一个循环往value值累加数字，最后会得到每个线程的累加值都一样。<strong>也就是说各个线程的value值是相互独立的，本线程的累加操作不会影响到其他线程的值，达到线程隔离的效果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestThreadLocal</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span> ＋ index + <span class="string">&quot;的初始value：&quot;</span> + value.get());</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">				value.set(value.get() + i);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;线程&quot;</span> + index + <span class="string">&quot;的累加value：&quot;</span> + value.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(i)).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>让我们自己来实现一个ThreadLocal，我们可能很容易就会想到通过封装一个Map对象来实现，Map 的key为线程的ID，value为对应的实例对象，这样就可以实现线程隔离的效果。早期的jdk版本也确实是这样实现的，但是在jdk8中，已经采用了别的实现方式，下面来具体的看一下</p>
<h4 id="重要的API"><a href="#重要的API" class="headerlink" title="重要的API"></a>重要的API</h4><ul>
<li><code>public T get()</code>: Returns the value in the current thread’s copy of this thread-local variable. If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the initialValue() method.</li>
<li><code>protected T initialValue()</code>: Returns the current thread’s “initial value” for this thread-local variable. This method will be invoked the first time a thread accesses the variable with the get() method, unless the thread previously invoked the set(T) method, in which case the initialValue method will not be invoked for the thread. This implementation simply returns null; if the programmer desires thread-local variables to have an initial value other than null, ThreadLocal must be subclassed, and this method overridden. Typically, an anonymous inner class will be used.</li>
<li><code>public void set(T value)</code>：Sets the current thread’s copy of this thread-local variable to the specified value</li>
<li><code>public void remove()</code>：Removes the current thread’s value for this thread-local variable. If this thread-local variable is subsequently read by the current thread, its value will be reinitialized by invoking its initialValue() method, unless its value is set by the current thread in the interim.</li>
</ul>
<h4 id="通过-get-方法的源码分析下ThreadLocal的设计"><a href="#通过-get-方法的源码分析下ThreadLocal的设计" class="headerlink" title="通过 get() 方法的源码分析下ThreadLocal的设计"></a>通过 get() 方法的源码分析下ThreadLocal的设计</h4><ul>
<li>public T get() 方法源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment">    * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">    * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">    * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>源码和注释其实非常的清晰，我们只需要根据代码的调用来走读一下即可，首先我们先获取当前线程t，然后获取对应线程t的ThreadLocalMap变量map，我们可以具体看一下<code>getMap(t)</code>的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">    * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在Thread类内部维护一个指向ThreadLocal的ThreadLocalMap包级私有静态类的字段：threadLocals，通过分析可以知道，<strong>整个ThreadLocal最核心的部分就在ThreadLocalMap类中，包括根据hash进行索引插入，通过开放地址法解决hash冲突问题等</strong>，部分代表代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/** ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment"> 	  * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment"> 	  * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment"> 	  * allow declaration of fields in class Thread.</span></span><br><span class="line"><span class="comment"> 	  * .....</span></span><br><span class="line"><span class="comment">	 /</span></span><br><span class="line"><span class="comment">	static class ThreadLocalMap &#123;</span></span><br><span class="line"><span class="comment">		static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span></span><br><span class="line"><span class="comment">			Object value;</span></span><br><span class="line"><span class="comment">			...</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		...</span></span><br><span class="line"><span class="comment">		private Entry[] table;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		/**</span></span><br><span class="line"><span class="comment">         * Get the entry associated with key.  This method</span></span><br><span class="line"><span class="comment">         * itself handles only the fast path: a direct hit of existing</span></span><br><span class="line"><span class="comment">         * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class="line"><span class="comment">         * designed to maximize performance for direct hits, in part</span></span><br><span class="line"><span class="comment">         * by making this method readily inlinable.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">			<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">			<span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">				<span class="keyword">return</span> e;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Version of getEntry method for use when key is not found in</span></span><br><span class="line"><span class="comment">         * its direct hash slot.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  i the table index for key&#x27;s hash code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span>  e the entry at table[i]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLoca&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码总结一下ThreadLocal的结构：<strong>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，内部由名为table的Entry数组维护，Entry的键值为当前ThreadLocal变量，value为变量副本（即T类型的变量)</strong></p>
<p>ThreadLocal 的 <code>public T get()</code> 方法的执行过程如下：</p>
<ul>
<li>先获取当前线程： Thread.currentThread()</li>
<li>根据当前线程获取 ThreadLocalMap(Entry 数组，Entry 继承自弱引用 WeakReference，Entry 的 key 为 ThreadLocal 值，value 为每个线程独立的值 Object): getMap(t)</li>
<li>如果map为空，调用setInitialValue() 方法进行初始化操作</li>
<li>map 不为空，获取threadLocal在该线程的中的value值：ThreadLocalMap.Entry e &#x3D; map.getEntry(this); T result &#x3D; (T) e.value;</li>
</ul>
<p>现在整个ThreadLocal的结构已经很清晰了，可以参考下面的图进行理解（<strong>图片的出处会在最后引用的文章链接中给出</strong>）</p>
<p><img src="https://0x80x17.tech/img/threadLocal.png"></p>
<h3 id="ThreadLocal的内存泄漏问题"><a href="#ThreadLocal的内存泄漏问题" class="headerlink" title="ThreadLocal的内存泄漏问题"></a>ThreadLocal的内存泄漏问题</h3><p>起因：ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br><code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code></p>
<p>解决：事实上jdk在设计的时候已经考虑到了这个情况，在getEntry函数和set函数中会对key为null的Entry进行擦出，<strong>但是</strong>，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的genEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。<strong>所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</strong></p>
<hr>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.decaywood.me/2016/03/15/ThreadLocal-intro/">ThreadLocal原理分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23089780/answer/62097840">ThreadLocal原理</a></li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>Java ThreadLocal解析(1)</p><p><span>文章作者：</span>Ryan</p><p><span>原始链接：</span><a href="/2023/02/12/Java-ThreadLocal解析-1/">https://0x80x17.tech/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://0x80x17.tech/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/"></i></span></p><p><span>版权声明：</span>转载或引用请注明本文链接🔗</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" rel="tag">线程&amp;并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a><a class="next" href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">语法</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 15px;">安全</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/06/01/%E5%85%B3%E4%BA%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">关于负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/17/%E5%85%B3%E4%BA%8E-Skip-list/">关于 Skip list</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/30/%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7/">熔断&降级</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/19/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">关于流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/%E8%81%8A%E8%81%8A%E5%B9%82%E7%AD%89/">聊聊幂等</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/15/Java-AQS%E8%A7%A3%E6%9E%90-2/">Java AQS解析(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/01/09/Java-AQS%E8%A7%A3%E6%9E%90-1/">Java AQS解析(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/15/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-2/">Java 内存模型解读(2)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>