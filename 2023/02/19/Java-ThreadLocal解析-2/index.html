<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java ThreadLocal解析(2) | 0x80x17</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java ThreadLocal解析(2)</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java ThreadLocal解析(2)</h1><div class="post-meta">2023-02-19</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7"><span class="toc-text">设计初衷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-text">内存泄漏问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%85%B6%E5%AE%83%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">ThreadLocal其它要注意的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol></div></div><div class="post-content"><p>前面写的关于ThreadLocal的文章<a href="https://0x80x17.tech/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a>，主要从ThreadLocal的一些基本知识和代码实现思路来整理，本文将试着从更加深入的角度来看ThreadLocal以及在使用TreadLocal 中遇到的一些坑。</p>
<h3 id="设计初衷"><a href="#设计初衷" class="headerlink" title="设计初衷"></a>设计初衷</h3><p>一句话：<strong>提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</strong></p>
<p>稍微展开来说一点，ThreadLocal的作用是提供线程内的局部变量 (类比方法的局部变量)，这种变量在自身线程的生命周期内起作用（其他线程访问不到），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度（同时隔离了多个线程）。</p>
<p>从上面的设计初衷，我们不难得出ThreadLocal的使用场景：</p>
<span id="more"></span>

<ul>
<li><p>在同一个线程中的多个函数需要操作相同的数据，使用线程局部变量(ThreadLocal)可以达到在本线程内的多个函数之间共享数据</p>
</li>
<li><p><strong>为多线程环境常出现的并发访问问题提供了一种隔离机制。</strong>通过ThreadLocal存取的数据，总是与当前线程相关，也就是说，JVM 为每个运行的线程，绑定了私有的本地实例存取空间， 从而为多线程环境常出现的并发访问问题提供了一种隔离机制。(<strong>对于多线程共享资源问题，同步机制采用了”时间换空间”的实现方式，而ThreadLocal采用了“空间换时间”的方式。</strong> 前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。)</p>
</li>
</ul>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>如果让我们自己来实现一个ThreadLocal，大家应该比较容易想到的方式是实用Map实现，用线程id作为key，线程对应的值作为value。JDK在最早期就是这样实现的，在最新的jdk中使用了新的方式，简单概括下：每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。具体点说就是：</p>
<ul>
<li>每个线程都有一个 ThreadLocalMap 类型的 threadLocals 属性</li>
<li>ThreadLocalMap 类相当于一个Map（<strong>该map底层是由 Entry 数组实现，和HashMap使用链地址法解决冲突不同，ThreadLocalMap使用了开放地址法解决哈希冲突</strong>），<strong>每一个 Entry 封装了 key－value 键值对，key 是 ThreadLocal 本身，value 就是我们的值</strong></li>
<li>当我们使用 threadLocal.set(new Integer(111)); 我们就会在这个线程中的 threadLocals 属性中放入一个键值对，key 就是这个 threadLocal，value 就是111</li>
<li>当我们通过 threadlocal.get() 方法的时候，首先会根据这个线程得到这个线程的 threadLocals 属性，然后由于这个属性放的是键值对，我们就可以根据键 threadlocal 拿到值。 注意，<strong>这时候这个键 threadlocal 和 我们 set 方法的时候的那个键 threadlocal 是一样的，所以我们能够拿到相同的值</strong></li>
</ul>
<p>通过上面描述我们就会思考，为什么jdk后来采用了新的实现方式，这是一个好问题，我认为一个比较合理的解释方式是使用Map来实现的ThreadLocal需要自己处理线程并发的问题，而使用Thread来维护一个threadLocalMap则不需要；另外当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</p>
<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><p>针对ThreadLocalMap使用弱引用的ThreadLocal来作为key，存在这样一种看法</p>
<blockquote>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链，永远无法回收，造成内存泄露。</p>
</blockquote>
<p>实际上造成ThreadLocal内存泄露的根本原因在于<strong>ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</strong>我们可以针对ThreadLocal使用强引用和弱引用分别来分析(下面分析来自其它博客，原文链接结尾会给出)：</p>
<blockquote>
<p>key 使用强引用：<br><br>引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。<br><br>key 使用弱引用：<br><br>引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br><br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</p>
</blockquote>
<p>综上，<strong>使用 threadlocal 要注意设置，清理上下文(因为线程池的原因）。每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</strong><br>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。（但是在清理上下文时，要注意会不会把其他业务代码中还在使用的同一个上下文给清理掉？）</p>
<p>而且JDK建议将ThreadLocal变量定义成<strong>private static</strong>的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
<h3 id="ThreadLocal其它要注意的问题"><a href="#ThreadLocal其它要注意的问题" class="headerlink" title="ThreadLocal其它要注意的问题"></a>ThreadLocal其它要注意的问题</h3><p>除了上面说的内存血泄漏问题，每次在使用时要注意设置清理上下文，还有其它要考虑的地方</p>
<ul>
<li>ThreadLocal不能解决父子线程传递问题</li>
</ul>
<p>JDK提供了<code>InheritableThreadLocal</code>来实现父子线程的传递问题</p>
<blockquote>
<p>This class extends ThreadLocal to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values. </p>
</blockquote>
<p>当我们创建一个新的线程的时候X，X线程就会有 ThreadLocalMap 类型的 inheritableThreadLocals，因为它是 Thread 类的一个属性。然后，先得到当前线程存储的这些值，例如 Entry[] parentTable &#x3D; parentMap.table; 再通过一个 for 循环，不断的把当前线程的这些值复制到我们新创建的线程X 的inheritableThreadLocals 中</p>
<ul>
<li>在线程池中使用ThreadLocal</li>
</ul>
<p>除了要注意设置清理上下文，并且在清理上下文时要注意不要把别的业务还在使用的上下文一起清除掉；还要注意线程池缓存线程带来的 ThreadLocal 取值不是任务提交时值。<strong>对于使用线程池等会缓存线程的组件的情况，线程由线程池创建好，并且线程是缓存起来反复使用的；这时父子线程关系的ThreadLocal值传递已经没有意义，应用需要的实际上是把 任务提交给线程池时的ThreadLocal值传递到 任务执行时。</strong>这时我们可以使用阿里开源的 <a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local">transmittable-thread-local</a></p>
<hr>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/22039.html">深入分析 ThreadLocal 内存泄漏问题</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17968803/threadlocal-memory-leak">ThreadLocal &amp; Memory Leak
</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local">alibaba&#x2F;transmittable-thread-local</a></li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>Java ThreadLocal解析(2)</p><p><span>文章作者：</span>Ryan</p><p><span>原始链接：</span><a href="/2023/02/19/Java-ThreadLocal解析-2/">https://0x80x17.tech/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://0x80x17.tech/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/"></i></span></p><p><span>版权声明：</span>转载或引用请注明本文链接🔗</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" rel="tag">线程&amp;并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" rel="tag">经验教训</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/03/03/%E8%81%8A%E8%81%8A%E5%B9%82%E7%AD%89/">聊聊幂等</a><a class="next" href="/2023/02/12/Java-ThreadLocal%E8%A7%A3%E6%9E%90-1/">Java ThreadLocal解析(1)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">语法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" style="font-size: 15px;">数据存储</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 15px;">安全</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/09/07/%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">位图与布隆过滤器</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/11/%E5%85%B3%E4%BA%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">关于负载均衡</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/24/%E5%85%B3%E4%BA%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/">关于流量控制</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/19/Redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Redis 中的数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/28/%E5%85%B3%E4%BA%8E-Skip-list/">关于 Skip list</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/05/DNS-%E6%A6%82%E8%BF%B0/">DNS 概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/30/%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7/">熔断&降级</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/19/%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%80%81/">关于多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/03/%E8%81%8A%E8%81%8A%E5%B9%82%E7%AD%89/">聊聊幂等</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/Java-ThreadLocal%E8%A7%A3%E6%9E%90-2/">Java ThreadLocal解析(2)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>