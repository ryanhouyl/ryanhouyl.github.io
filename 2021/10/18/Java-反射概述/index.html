<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java 反射概述 | 0x80x17</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 反射概述</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 反射概述</h1><div class="post-meta">2021-10-18</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-text">怎么用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Class-%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建 Class 类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取 Class 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-Class-%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">实例化 Class 对象对应的类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">Class 类对象可以做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-text">反射与动态加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">反射与泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3"><span class="toc-text">反射与注解</span></a></li></ol></div></div><div class="post-content"><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>反射作为 Java 语言的一大特性，在底层框架实现中应用广泛，从字面上来理解，反射就类似于照镜子，是一个类自己在“照镜子”。在 Java 中我们提供了 <code>Class</code> 类及相关的类如 <code>Field</code>，<code>Method</code> 等来实现反射，<strong>Class 类封装了当前对象对应的类的信息，也就是 Class 类是描述我们定义的类的类。相当于在我们自己定义的类上又抽象了一层。</strong>对于每个类而言，JVM 中最多都只有一个不变的 Class 类型的对象来标示该类</p>
<p>Reflection VS Introspection</p>
<span id="more"></span>

<blockquote>
<p>The ability to inspect the code in the system and see object types is not reflection, but rather Type Introspection. Reflection is then the ability to make modifications at runtime by making use of introspection. </p>
</blockquote>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><h3 id="创建-Class-类对象"><a href="#创建-Class-类对象" class="headerlink" title="创建 Class 类对象"></a>创建 Class 类对象</h3><p>Class 对象只能由 JVM 在类加载时创建，一个类在 JVM 中最多只有一个对应的 Class 实例</p>
<h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>我们有三种方式获取 Class 对象</p>
<ul>
<li>通过类的 class 属性获取，该方法最安全可靠，性能更高： <code>Class&lt;String&gt; clazz = String.class;</code></li>
<li>通过对象的<strong>getClass() 方法</strong>获取：<code>Class&lt;String&gt; clazz = &quot;hello&quot;.getClass();</code></li>
<li>通过 Class 的<strong>static forName()方法</strong>获取，但可能抛出 <strong>ClassNotFoundException 异常</strong>(这个方法常在框架中使用，比如使用 JDBC 时获取数据库驱动类的 Class 类对象)：<code>Class&lt;?&gt; contextClass = Class.forName(&quot;org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;);</code></li>
</ul>
<h3 id="实例化-Class-对象对应的类的对象"><a href="#实例化-Class-对象对应的类的对象" class="headerlink" title="实例化 Class 对象对应的类的对象"></a>实例化 Class 对象对应的类的对象</h3><p>获取了 Class 对象，就可以实例化对应的类对象了，可以通过 Class 对象的<strong>newInstance()方法</strong>来创建类的一个实例:<code>Object obj = clazz.newInstance()</code>，实际上调用的是类的无参构造器（如果想要通过该方式实例化一个对象，需要保证类的无参构造器存在）</p>
<h3 id="Class-类对象可以做什么"><a href="#Class-类对象可以做什么" class="headerlink" title="Class 类对象可以做什么"></a>Class 类对象可以做什么</h3><p>既然 Class 是对类的描述，那么 Class对象就应该可以使用该类的属性(Filed)，该类的方法(Method)，该类的构造器(Constructor)。我们都知道 Java 是面向对象的语言，这种OO 思想在这里也得以体现：一个成员方法就是一个<strong>Method对象</strong>，一个成员变量就是一个<strong>Field对象</strong>，在 Java 中提供了相应的 <code>Method类</code> 和 <code>Field类</code>等，还有具体的 API 方法，举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;coim.javase.Person&quot;</span>);</span><br><span class="line"><span class="comment">// 获取 Class 对象声明的所有方法，包括 private 方法，但是不包括继承的方法</span></span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若通过反射执行私有方法权限不够，先使该方法变为可被访问的</span></span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">Field[] fiedls = clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">// 获取指定名字的 Field</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the Class representing the superclass of the entity (class, interface, primitive type or void) represented by this Class</span></span><br><span class="line">Class&lt;?&gt; parentClazz = clazz.getSuperclass();</span><br></pre></td></tr></table></figure>

<p>通过上面那些方法可以得到一堆好东西，包括方法啊，字段啊，构造器啊等，接下来就可以按需应用了，Method 类有一个方法很重要，单独提一下: <code>public Object invoke(Object obj, Object ... args)</code>，我们可以通过 Method 对象的此方法来执行对象相应的方法。在调用这个方法的前后，我们可以加些自定义的操作，比如打印日志，开启事务等，这就可以用来实现 AOP</p>
<h3 id="反射与动态加载"><a href="#反射与动态加载" class="headerlink" title="反射与动态加载"></a>反射与动态加载</h3><p>使用<strong>关键字new</strong>创建对象时，需要在编译期就知道要使用到的具体的类，这会影响程序的灵活性。使用反射我们可以在运行期动态加载需要的类，即 <code>Class&lt;?&gt; c = Class.forName(args[0]); </code>这里还可以再扩展一下，在通过 c 实例化具体的对象时（T newInstance()），我们需要做强制类型转换，可是转换成谁呢？我们应该马上想到定义一个抽象接口，然后用不同的类来具体实现，以实现动态绑定。使用这种面向接口编程的方式，可以提供更好的灵活性和稳定性</p>
<h2 id="反射与泛型"><a href="#反射与泛型" class="headerlink" title="反射与泛型"></a>反射与泛型</h2><p>Java 泛型是编译器实现的语法糖，在运行期泛型信息会被擦除，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list1.add(<span class="number">20</span>); <span class="comment">// 编译报错，泛型提供了类型安全检查</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; c = list.getClass();</span><br><span class="line">Class&lt;?&gt; c1 = list1.getClass();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> (c == c1); <span class="comment">// 这里 b 的值为 true</span></span><br></pre></td></tr></table></figure>

<p>布尔值 b 为 ture 这件事告诉我们<strong>编译之后集合的泛型信息被擦除了</strong>，这句话非常有价值，有了这个基础我们就可以在上面例子中加入我们想要加入的整数而不出现错误，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射绕过泛型限制</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c1.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">m.invoke(list1, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>我们有时还需要获取泛型的实际类型参数，下面介绍一下通过反射获得实际类型参数的方法:（这里需要用到 Type 接口和ParameterizedType 接口，具体内容可以查看相应的接口文档）</p>
<p>例：<code>public EmployeeDao extends BaseDao&lt;Employee, String&gt;</code>，下面方法中，clazz 为子类对应的 Class对象，index 为子类继承父类时传入的泛型参数索引，从 0 开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父类指定索引的实际类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getSuperClassGenericType(Class&lt;?&gt; clazz, <span class="type">int</span> index) &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">    <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type[] types = ((ParameterizedType) t).getActualTypeArguments();</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= param.length || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal index param.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Class)types[index];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="反射与注解"><a href="#反射与注解" class="headerlink" title="反射与注解"></a>反射与注解</h2><p>反射经常搭配注解一起使用，注解信息可以在运行时通过反射获取，然后根据获取的注解执行相应的逻辑。通过使用 Annotation 我们可以在不改变原有逻辑的情况下，在代码中嵌入一些补充信息和逻辑，举例说明比较直观：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 Annotation</span></span><br><span class="line"><span class="meta">@Rentetion(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123; ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AgeValidator &#123;</span><br><span class="line">    <span class="comment">// 注解和接口类似，内部可以定义常量和方法</span></span><br><span class="line">    <span class="comment">// 注解定义的方法有一些限制：方法不能有参数；返回值只能是基本类型、字符串、Class、枚举、注解、及以上类型的数组；可以包含默认值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">DEFAULT_MIN</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> DEFAULT_MIN;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@AgeValidator(max = 30)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取注解信息，进行相应的处理</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMdthod(<span class="string">&quot;setAge&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Annotation</span> <span class="variable">an</span> <span class="operator">=</span> method.getAnnotation(AgeValidator.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (an != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">AgeValidator</span> <span class="variable">av</span> <span class="operator">=</span> (AgeValidator) an;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; av.min() || val &gt; av.max()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid age&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">method.invoke(obj, val);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上述代码就是通过反射和注解来进行元编程的一个简单实现，当然这里只是抛砖引玉，像这样的使用你可以在框架中(比如 SpringBoot 中等)发现很多，我们在使用框架时也要多考虑一下底层实现，只有这样才不会对层出不穷的新框架感到害怕</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>Java 反射概述</p><p><span>文章作者：</span>Ryan</p><p><span>原始链接：</span><a href="/2021/10/18/Java-反射概述/">https://0x80x17.tech/2021/10/18/Java-%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://0x80x17.tech/2021/10/18/Java-%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0/"></i></span></p><p><span>版权声明：</span>转载或引用请注明本文链接🔗</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul></div><div class="post-nav"><a class="pre" href="/2021/10/29/%E7%AE%80%E8%B0%88-Java%E6%B3%9B%E5%9E%8B/">简谈 Java泛型</a><a class="next" href="/2021/10/07/Java-%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/">Java 嵌套类的使用</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/10/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/">零拷贝技术解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/25/Sharding-IDs-at-Instagram/">Sharding & IDs at Instagram</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/03/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM 类加载器</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/21/%E4%BB%8E%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%88%B0-KMP%E7%AE%97%E6%B3%95/">从简单模式匹配到 KMP算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/21/null-awareness/">null awareness</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/06/01/Using-and-avoiding-null/">Using and avoiding null</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/05/27/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/">作用域与闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/13/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/">重新认识信息隐藏</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/04/05/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8-Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">回调及在 Java中的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/19/Debunking-the-Myths-of-RPC-REST/">Debunking the Myths of RPC&REST</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>