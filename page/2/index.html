<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>0x80x17 | hello, world:)</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">0x80x17</h1><a id="logo" href="/.">0x80x17</a><p class="description">hello, world:)</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2022/06/21/null-awareness/">null awareness</a></h1><div class="post-meta">2022-06-21</div><div class="post-content"><p>前面翻译了一篇关于如何合理使用 null 的文章:<a href="https://0x80x17.tech/2022/06/01/Using-and-avoiding-null/">Using and avoiding null</a>，考虑到 null 的普遍性和 NPE 带来的大量问题，再写一篇文章做个总结是有必要的</p>
<h2 id="null-是什么"><a href="#null-是什么" class="headerlink" title="null 是什么"></a>null 是什么</h2><p>null 是任何一个引用类型变量的默认值。设计初衷是为了表示一些缺失的东西，比如缺失的资源或其他东西，再具体点说:</p></div><p class="readmore"><a href="/2022/06/21/null-awareness/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/06/01/Using-and-avoiding-null/">Using and avoiding null</a></h1><div class="post-meta">2022-06-01</div><div class="post-content"><p>文章翻译自 Google Guava 文档，原文链接: <a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained">Using and avoiding null</a></p>
<h3 id="Why-avoid-null？"><a href="#Why-avoid-null？" class="headerlink" title="Why avoid null？"></a>Why avoid null？</h3><blockquote>
<p>“Null sucks.” -Doug Lea<br><br><br>“I call it my billion-dollar mistake.” - Sir C. A. R. Hoare, on his invention of the null reference</p>
</blockquote>
<p>随意使用 null 会带来比预料中更多的 bug。在研究了 Google 内部的代码库后，发现在高达95%的情况下，collections 中不应该有任何 null 值，对于开发者来说，往 collections 中添加 null 时 fail fast 而不是默默接受是更合理的</p></div><p class="readmore"><a href="/2022/06/01/Using-and-avoiding-null/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/05/27/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/">作用域与闭包</a></h1><div class="post-meta">2022-05-27</div><div class="post-content"><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>简单来说一句话：<strong>带上下文的函数</strong>，下面展开说明一下</p>
<p>声明：接下来的部分内容来自对 StackOverflow 回答的翻译，原答案链接 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/36636/what-is-a-closure">What is a ‘Closure’?</a></p>
<p>要想理解好闭包，首先要弄清楚 <code>Scope</code>，当我们声明一个局部变量时，这个变量会有一个 Scope，通常局部变量仅在声明它的 block 或 function 中有效，比如下面 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// works</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// fails</span></span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2022/05/27/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/04/13/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/">重新认识信息隐藏</a></h1><div class="post-meta">2022-04-13</div><div class="post-content"><h2 id="一个重要却容易忽略的问题"><a href="#一个重要却容易忽略的问题" class="headerlink" title="一个重要却容易忽略的问题"></a>一个重要却容易忽略的问题</h2><p>在谈到 OOP 时，大家一般会想到<strong>封装，继承和多态</strong>，所谓封装，就是将数据与相关行为包装在一起以实现信息隐藏。更准确的来说，<strong>信息隐藏是我们编程时的原则，而封装是实现信息隐藏的一种方式。</strong>那信息隐藏为什么如此重要？</p>
<p>引用一段<code>Effective Java</code>中的话：</p>
<blockquote>
<p>要区别设计良好的模块和设计不好的模块，重要的标志在于，这个模块对于外部其他模块而言，是否隐藏其内部数据和实现细节。设计良好的模块会隐藏所有的实现细节，模块间仅通过API进行通信</p>
</blockquote></div><p class="readmore"><a href="/2022/04/13/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/04/05/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8-Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">回调及在 Java中的使用</a></h1><div class="post-meta">2022-04-05</div><div class="post-content"><h2 id="回调是什么"><a href="#回调是什么" class="headerlink" title="回调是什么"></a>回调是什么</h2><p>维基百科的定义如下:</p>
<blockquote>
<p>In computer programming, a callback, also known as a “call-after” function, is any executable code that is passed as an argument to other code; that other code is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers.</p>
</blockquote>
<p>可以类比打电话帮助理解：方法调用可以类比为给某人打电话，然后问他一个问题，得到答案后挂掉电话；那么回调就可以类比为，打电话询问问题后，把你的名字和电话告诉他(register a callback function)，这样他就可以在知道答案后再打电话回答你(callback)</p></div><p class="readmore"><a href="/2022/04/05/%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%9C%A8-Java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/03/19/Debunking-the-Myths-of-RPC-REST/">Debunking the Myths of RPC&amp;REST</a></h1><div class="post-meta">2022-03-19</div><div class="post-content"><p>本文为翻译文章，原文链接为:<a target="_blank" rel="noopener" href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/">Debunking the Myths of RPC &amp; REST</a></p>
<p>网上有很多关于 RPC 和 REST 的文章，博客与讨论，但是大部分都在回答某一个特定的应用下，应该选择使用 RPC 还是 REST，而这本身并不是一个正确的二分法。这些回答普遍没有解释我想要知道的问题，而是让我感觉到大部分的开发者并不懂为什么要使用 REST，仅仅是因为觉得这个架构听起来很酷。讽刺的是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a>在介绍 REST 的论文中就提到了这种**”design by fad”**</p>
<blockquote>
<p>“Consider how often we see software projects begin with adoption of the latest fad in architectural design, and only later discover whether or not the system requirements call for such an architecture.”</p>
</blockquote></div><p class="readmore"><a href="/2022/03/19/Debunking-the-Myths-of-RPC-REST/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/03/03/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%80%9D%E8%B7%AF/">反转单链表的三种经典思路</a></h1><div class="post-meta">2022-03-03</div><div class="post-content"><p>基础的数据结构和算法题目，基础但是很有意义，本文整理三种不同的实现思路。</p>
<h2 id="头插法构建单链表"><a href="#头插法构建单链表" class="headerlink" title="头插法构建单链表"></a>头插法构建单链表</h2><p>头插法操作一组数据后生成逆序的单链表，利用这个性质，我们可以遍历给定的单链表，利用头插法建立新的单链表，最后返回链表的头节点即可。实现简单，但是需要开辟额外的空间，空间复杂度和时间复杂度都是 <code>O(n)</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkNode <span class="title function_">reverse</span><span class="params">(LinkNode head)</span> &#123;</span><br><span class="line">    <span class="type">LinkNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkNode</span>(head.val);</span><br><span class="line">        cur.next = dummy.next;</span><br><span class="line">        dummy.next = cur;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2022/03/03/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%80%9D%E8%B7%AF/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/02/27/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/">创建一个对象的思考</a></h1><div class="post-meta">2022-02-27</div><div class="post-content"><h2 id="事情可能没有看起来那么简单"><a href="#事情可能没有看起来那么简单" class="headerlink" title="事情可能没有看起来那么简单"></a>事情可能没有看起来那么简单</h2><p>Java 作为支持 OOP 的语言，对象创建自然是最基本的，然而如何更合理的创建对象这件事，并没有想当然那么简单，不是无脑的使用 new 关键字加构造器就完了。那么创建一个对象，我们可能要思考哪些问题呢？</p>
<ul>
<li>创建方式: 是直接通过 new 关键字加构造器创建，还是使用工厂类，或者 Builder，或者反射，克隆，反序列化呢？</li>
<li>数量: 是构造单例对象，还是通过对象池构造有限个对象，还是不加限制呢？</li>
<li>时间: 是立即构建，还是延迟构建呢？</li>
<li>形式: 是构造实际对象，还是构造代理对象？是本地对象，还是远程对象的 stub？</li>
</ul></div><p class="readmore"><a href="/2022/02/27/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/02/16/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">模版方法模式VS策略模式</a></h1><div class="post-meta">2022-02-16</div><div class="post-content"><p>模版方法模式和策略模式是两个”神似”的设计模式，都通过抽象把代码的可变部分提取，使整理保持灵活。但两者在实现方式和侧重点上还是各有不同的，下面展开叙述</p>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote>
<p>在一个方法(模版方法)中定义好算法骨架，将一些可变步骤延迟到子类中定义。模版方法使得子类可以在不改变算法结构的前提下，复用父类的代码，同时可以重新定义算法中的某些步骤</p>
</blockquote></div><p class="readmore"><a href="/2022/02/16/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2022/02/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/">单例模式的各种姿势</a></h1><div class="post-meta">2022-02-02</div><div class="post-content"><p>在很多场景下，我们的类只允许有一个实例对象，比如注册表，计数器，任务管理器等，这时我们就需要使用单例模式来创建唯一的对象供程序使用。单例模式是很基础且常用的设计模式，有多种实现方式，下面总结一下</p>
<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>因为要保证一个类只有一个实例对象，所以我们要私有化类的构造器，避免应用程序代码通过 new 关键字来实例化对象，同时要提供一个静态方法供应用程序访问该单例，很容易想到的实现代码如下：</p></div><p class="readmore"><a href="/2022/02/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF/">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://0x80x17.tech"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Lean Coder.</p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15px;">设计</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">分布式系统</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 15px;">翻译</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15px;">虚拟机</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">线程&并发</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 15px;">中间件</a> <a href="/tags/%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" style="font-size: 15px;">经验教训</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构&算法</a> <a href="/tags/JS/" style="font-size: 15px;">JS</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/12/12/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-1/">Java 内存模型解读(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/12/11/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB-2/">Java 内存模型解读(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/29/%E5%86%8D%E8%B0%88-Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">再谈 Java线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/13/Visitor-Pattern-Tutorial/">Visitor Pattern Tutorial</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/11/02/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Java 线程池实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/11/Redis-Cluster%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/">Redis Cluster扩展性和可用性设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/04/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/">零拷贝技术解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/09/25/Sharding-IDs-at-Instagram/">Sharding & IDs at Instagram</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/03/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM 类加载器</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/21/%E4%BB%8E%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%88%B0-KMP%E7%AE%97%E6%B3%95/">从简单模式匹配到 KMP算法</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">0x80x17.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>